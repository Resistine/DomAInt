{"version":3,"file":"./src/mergedSettings.js","mappings":";;AAAA;AACA;AACA;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://domaint/webpack/bootstrap","webpack://domaint/webpack/runtime/define property getters","webpack://domaint/webpack/runtime/hasOwnProperty shorthand","webpack://domaint/webpack/runtime/make namespace object","webpack://domaint/./src/mergedSettings.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// getting DOM elements from popup.html\n\n// get toggleButton (used to enable/disable autoClose)\nlet toggleButton = document.getElementById(\"toggleButton\");\n//let clearWhitelist = document.getElementById(\"clearWhiteList\");\n\nlet blackListdiv = document.getElementById(\"blacklist\");\nlet whiteListdiv = document.getElementById(\"whitelist\");\n\n// adding listeners to DOM elements triggering their responsible functions\nif (toggleButton) {\n    toggleButton.addEventListener(\"click\", toggle);\n}\n/**\n \n *toggle function is responsible for turning off/on blacklist site autoclose\n *and saving the value to the local storage\n */\nexport function toggle() {\n    console.log(\"toggle\");\n    // get autoclose and its values from browser storage\n    let autoClose = chrome.storage.local.get(\"autoClose\");\n    autoClose.then((res) => {\n        // set the setting to the html value\n        let settings = chrome.storage.local.set({\n            autoClose: toggleButton.checked\n        });\n        //after settings are saved, update the html button's value to the set one\n        settings.then(function () {\n            updateButton();\n        });\n    });\n}\n\n/**\n * function updateButton is called when on optionsPage, when the autoClose settings are changed\n */\nexport function updateButton() {\n    //get the value from browser storage\n    let buttonVal = chrome.storage.local.get(\"autoClose\");\n    buttonVal.then((val) => {\n        // if autoClose is not enabled yet or does not exist, disable it by default\n        if (!val.autoClose || val.autoClose == null) {\n            toggleButton.checked = false;\n            //otherwise set it enable it\n        } else {\n            toggleButton.checked = true;\n        }\n    });\n}\n\n\nexport function checkForDuplicates(domain, regDom, callback) {\n    let blackListedSites;\n    let whiteListedSites;\n\n    // get blackListed sites from browser storage\n    let blackList = chrome.storage.local.get(\"blackList\");\n    blackList.then((res) => {\n        // check if there are any blacklisted sites\n        if (!res.blackList || res.blackList.length < 1) {\n            blackListedSites = [];\n            // parse blackListed sites to object\n        } else {\n            blackListedSites = JSON.parse(res.blackList);\n        }\n        // get whiteListed sites from browser storage\n        let whiteList = chrome.storage.local.get(\"whiteList\");\n        whiteList.then((res) => {\n            // check if there are any blacklisted sites\n            if (!res.whiteList || res.whiteList.left < 1) {\n                whiteListedSites = [];\n                // parse blackListed sites to object\n            } else {\n                whiteListedSites = JSON.parse(res.whiteList);\n            }\n\n            //check if site, user wishes to block is not already blocked\n            if (blackListedSites.some(e => e[\"domain\"] === domain) || blackListedSites.some(x => x[\"regex\"] === regDom)) {\n                //log if so\n                //TODO create some sort of flash message to popup and options page\n                console.log(\"this site is already being blocked\");\n                return;\n            } else {\n                for (let j = 0; j < whiteListedSites.length; j++) {\n                    if (whiteListedSites[j][\"domain\"] == domain || whiteListedSites[j][\"regex\"] == regDom) {\n                        console.log(`removed ${whiteListedSites[j][\"domain\"]} from the whitelist`);\n                        whiteListedSites.splice(j, 1);\n\n                        chrome.storage.local.set({\n                            whiteList: JSON.stringify(whiteListedSites),\n                        });\n                        break;\n                    }\n                }\n            }\n\n\n            console.log(blackListedSites);\n            callback(blackListedSites);\n        });\n    });\n\n}\n\n\nexport function checkForDuplicatesWhitelist(domain, regDom, callback) {\n    let whiteListedSites;\n    let blackListedSites;\n\n    // get whiteListed sites from browser storage\n    let whiteList = chrome.storage.local.get(\"whiteList\");\n    whiteList.then((res) => {\n        // check if there are any blacklisted sites\n        if (!res.whiteList || res.whiteList.left < 1) {\n            whiteListedSites = [];\n            // parse blackListed sites to object\n        } else {\n            whiteListedSites = JSON.parse(res.whiteList);\n        }\n\n        // get blackListed sites from browser storage\n        let blackList = chrome.storage.local.get(\"blackList\");\n        blackList.then((res) => {\n            // check if there are any blacklisted sites\n            if (!res.blackList || res.blackList.left < 1) {\n                blackListedSites = [];\n                // parse blackListed sites to object\n            } else {\n                blackListedSites = JSON.parse(res.blackList);\n            }\n\n            //check if site, user wishes to block is not already blocked\n            if (whiteListedSites.some(e => e[\"domain\"] === domain) || whiteListedSites.some(x => x[\"regex\"] === regDom)) {\n                //log if so\n                //TODO create some sort of flash message to popup and options page\n                console.log(\"this site is already in the whitelist\");\n                return;\n            } else {\n                for (let j = 0; j < blackListedSites.length; j++) {\n                    if (blackListedSites[j][\"domain\"] == domain || blackListedSites[j][\"regex\"] == regDom) {\n                        console.log(`removed ${blackListedSites[j][\"domain\"]} from the blacklist`);\n                        blackListedSites.splice(j, 1);\n\n                        chrome.storage.local.set({\n                            blackList: JSON.stringify(blackListedSites),\n                        });\n                        break;\n                    }\n                }\n            }\n\n            console.log(whiteListedSites);\n            callback(whiteListedSites);\n\n        });\n    });\n}\n\n\n\n/**\n *function addSite gets URL value from html form user wishes to whitelist\n */\nexport function addToWhiteList(url) {\n    let domain = url;\n    // parse full url to domain adress only\n    let regDom = domain\n            .replace(\"http://\", \"\")\n            .replace(\"https://\", \"\")\n            .replace(\"www.\", \"\")\n            .split(/[/?#]/)[0];\n\n    let whiteListedSites = checkForDuplicatesWhitelist(domain, regDom, function (whiteListedSites) {\n        console.log(whiteListedSites);\n\n        if (whiteListedSites) {\n            // create object made of full URL and parsed URL\n            const object = {\n                domain: domain,\n                regex: regDom,\n            };\n\n            // push the previous object to the existing whitelist\n            whiteListedSites.push(object);\n\n            // save whiteListed sites to the browser storage\n            chrome.storage.local.set({\n                whiteList: JSON.stringify(whiteListedSites),\n            });\n\n            //log if succesfully accomplished\n            //TODO create some sort of flash message to popup and options page\n            console.log(\"succesfully added domain to the whiteList\");\n        } else {\n            return;\n        }\n    });\n}\n\nexport function getBlacklist() {\n    let blackListedSites;\n\n    // get blackListed sites from browser storage\n    let blackList = chrome.storage.local.get(\"blackList\");\n    blackList.then((res) => {\n        // check if there are any blacklisted sites\n        if (!res.blackList || res.blackList.length < 1) {\n            blackListedSites = [];\n            // parse blackListed sites to object\n        } else {\n            blackListedSites = JSON.parse(res.blackList);\n        }\n\n        return new Promise(function (resolve, reject) {\n            if (blackListedSites) {\n                resolve(blackListedSites);\n            } else {\n                reject(new Error(\"could not return the blacklist\"));\n            }\n        });\n    });\n}\n\nexport function getWhitelist() {\n    let whiteListedSites;\n\n    // get whiteListed sites from browser storage\n    let whiteList = chrome.storage.local.get(\"whiteList\");\n    whiteList.then((res) => {\n        // check if there are any whitelisted sites\n        if (!res.whiteList || res.whiteList.length < 1) {\n            whiteListedSites = [];\n            // parse whiteListed sites to object\n        } else {\n            whiteListedSites = JSON.parse(res.whiteList);\n        }\n\n        return new Promise(function (resolve, reject) {\n            if (whiteListedSites) {\n                resolve(whiteListedSites);\n            } else {\n                reject(new Error(\"could not return the whitelist\"));\n            }\n        });\n    });\n}\n\nif (toggleButton) {\n    updateButton();\n}\n"],"names":[],"sourceRoot":""}