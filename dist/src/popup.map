{"version":3,"file":"./src/popup.js","mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://domaint/./src/mergedSettings.js","webpack://domaint/webpack/bootstrap","webpack://domaint/webpack/runtime/define property getters","webpack://domaint/webpack/runtime/hasOwnProperty shorthand","webpack://domaint/webpack/runtime/make namespace object","webpack://domaint/./src/popup.js"],"sourcesContent":["// getting DOM elements from popup.html\n\n// get toggleButton (used to enable/disable autoClose)\nlet toggleButton = document.getElementById(\"toggleButton\");\n//let clearWhitelist = document.getElementById(\"clearWhiteList\");\n\nlet blackListdiv = document.getElementById(\"blacklist\");\nlet whiteListdiv = document.getElementById(\"whitelist\");\n\n// adding listeners to DOM elements triggering their responsible functions\nif (toggleButton) {\n    toggleButton.addEventListener(\"click\", toggle);\n}\n/**\n \n *toggle function is responsible for turning off/on blacklist site autoclose\n *and saving the value to the local storage\n */\nexport function toggle() {\n    console.log(\"toggle\");\n    // get autoclose and its values from browser storage\n    let autoClose = chrome.storage.local.get(\"autoClose\");\n    autoClose.then((res) => {\n        // set the setting to the html value\n        let settings = chrome.storage.local.set({\n            autoClose: toggleButton.checked\n        });\n        //after settings are saved, update the html button's value to the set one\n        settings.then(function () {\n            updateButton();\n        });\n    });\n}\n\n/**\n * function updateButton is called when on optionsPage, when the autoClose settings are changed\n */\nexport function updateButton() {\n    //get the value from browser storage\n    let buttonVal = chrome.storage.local.get(\"autoClose\");\n    buttonVal.then((val) => {\n        // if autoClose is not enabled yet or does not exist, disable it by default\n        if (!val.autoClose || val.autoClose == null) {\n            toggleButton.checked = false;\n            //otherwise set it enable it\n        } else {\n            toggleButton.checked = true;\n        }\n    });\n}\n\n\nexport function checkForDuplicates(domain, regDom, callback) {\n    let blackListedSites;\n    let whiteListedSites;\n\n    // get blackListed sites from browser storage\n    let blackList = chrome.storage.local.get(\"blackList\");\n    blackList.then((res) => {\n        // check if there are any blacklisted sites\n        if (!res.blackList || res.blackList.length < 1) {\n            blackListedSites = [];\n            // parse blackListed sites to object\n        } else {\n            blackListedSites = JSON.parse(res.blackList);\n        }\n        // get whiteListed sites from browser storage\n        let whiteList = chrome.storage.local.get(\"whiteList\");\n        whiteList.then((res) => {\n            // check if there are any blacklisted sites\n            if (!res.whiteList || res.whiteList.left < 1) {\n                whiteListedSites = [];\n                // parse blackListed sites to object\n            } else {\n                whiteListedSites = JSON.parse(res.whiteList);\n            }\n\n            //check if site, user wishes to block is not already blocked\n            if (blackListedSites.some(e => e[\"domain\"] === domain) || blackListedSites.some(x => x[\"regex\"] === regDom)) {\n                //log if so\n                //TODO create some sort of flash message to popup and options page\n                console.log(\"this site is already being blocked\");\n                return;\n            } else {\n                for (let j = 0; j < whiteListedSites.length; j++) {\n                    if (whiteListedSites[j][\"domain\"] == domain || whiteListedSites[j][\"regex\"] == regDom) {\n                        console.log(`removed ${whiteListedSites[j][\"domain\"]} from the whitelist`);\n                        whiteListedSites.splice(j, 1);\n\n                        chrome.storage.local.set({\n                            whiteList: JSON.stringify(whiteListedSites),\n                        });\n                        break;\n                    }\n                }\n            }\n\n\n            console.log(blackListedSites);\n            callback(blackListedSites);\n        });\n    });\n\n}\n\n\nexport function checkForDuplicatesWhitelist(domain, regDom, callback) {\n    let whiteListedSites;\n    let blackListedSites;\n\n    // get whiteListed sites from browser storage\n    let whiteList = chrome.storage.local.get(\"whiteList\");\n    whiteList.then((res) => {\n        // check if there are any blacklisted sites\n        if (!res.whiteList || res.whiteList.left < 1) {\n            whiteListedSites = [];\n            // parse blackListed sites to object\n        } else {\n            whiteListedSites = JSON.parse(res.whiteList);\n        }\n\n        // get blackListed sites from browser storage\n        let blackList = chrome.storage.local.get(\"blackList\");\n        blackList.then((res) => {\n            // check if there are any blacklisted sites\n            if (!res.blackList || res.blackList.left < 1) {\n                blackListedSites = [];\n                // parse blackListed sites to object\n            } else {\n                blackListedSites = JSON.parse(res.blackList);\n            }\n\n            //check if site, user wishes to block is not already blocked\n            if (whiteListedSites.some(e => e[\"domain\"] === domain) || whiteListedSites.some(x => x[\"regex\"] === regDom)) {\n                //log if so\n                //TODO create some sort of flash message to popup and options page\n                console.log(\"this site is already in the whitelist\");\n                return;\n            } else {\n                for (let j = 0; j < blackListedSites.length; j++) {\n                    if (blackListedSites[j][\"domain\"] == domain || blackListedSites[j][\"regex\"] == regDom) {\n                        console.log(`removed ${blackListedSites[j][\"domain\"]} from the blacklist`);\n                        blackListedSites.splice(j, 1);\n\n                        chrome.storage.local.set({\n                            blackList: JSON.stringify(blackListedSites),\n                        });\n                        break;\n                    }\n                }\n            }\n\n            console.log(whiteListedSites);\n            callback(whiteListedSites);\n\n        });\n    });\n}\n\n\n\n/**\n *function addSite gets URL value from html form user wishes to whitelist\n */\nexport function addToWhiteList(url) {\n    let domain = url;\n    // parse full url to domain adress only\n    let regDom = domain\n            .replace(\"http://\", \"\")\n            .replace(\"https://\", \"\")\n            .replace(\"www.\", \"\")\n            .split(/[/?#]/)[0];\n\n    let whiteListedSites = checkForDuplicatesWhitelist(domain, regDom, function (whiteListedSites) {\n        console.log(whiteListedSites);\n\n        if (whiteListedSites) {\n            // create object made of full URL and parsed URL\n            const object = {\n                domain: domain,\n                regex: regDom,\n            };\n\n            // push the previous object to the existing whitelist\n            whiteListedSites.push(object);\n\n            // save whiteListed sites to the browser storage\n            chrome.storage.local.set({\n                whiteList: JSON.stringify(whiteListedSites),\n            });\n\n            //log if succesfully accomplished\n            //TODO create some sort of flash message to popup and options page\n            console.log(\"succesfully added domain to the whiteList\");\n        } else {\n            return;\n        }\n    });\n}\n\nexport function getBlacklist() {\n    let blackListedSites;\n\n    // get blackListed sites from browser storage\n    let blackList = chrome.storage.local.get(\"blackList\");\n    blackList.then((res) => {\n        // check if there are any blacklisted sites\n        if (!res.blackList || res.blackList.length < 1) {\n            blackListedSites = [];\n            // parse blackListed sites to object\n        } else {\n            blackListedSites = JSON.parse(res.blackList);\n        }\n\n        return new Promise(function (resolve, reject) {\n            if (blackListedSites) {\n                resolve(blackListedSites);\n            } else {\n                reject(new Error(\"could not return the blacklist\"));\n            }\n        });\n    });\n}\n\nexport function getWhitelist() {\n    let whiteListedSites;\n\n    // get whiteListed sites from browser storage\n    let whiteList = chrome.storage.local.get(\"whiteList\");\n    whiteList.then((res) => {\n        // check if there are any whitelisted sites\n        if (!res.whiteList || res.whiteList.length < 1) {\n            whiteListedSites = [];\n            // parse whiteListed sites to object\n        } else {\n            whiteListedSites = JSON.parse(res.whiteList);\n        }\n\n        return new Promise(function (resolve, reject) {\n            if (whiteListedSites) {\n                resolve(whiteListedSites);\n            } else {\n                reject(new Error(\"could not return the whitelist\"));\n            }\n        });\n    });\n}\n\nif (toggleButton) {\n    updateButton();\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import {checkForDuplicates, addToWhiteList} from \"./mergedSettings\"\n\n// getting DOM elements from popup.html\n\n// get cDomain button (used to add current site to the blacklist)\nlet currentToBlacklist = document.getElementById(\"cDomain\");\n// get whitelist button (used to add current site to the whitelist)\nlet currentToWhitelist = document.getElementById(\"whitelist\");\n// get options button (used to open extension's options page on a new tab)\nlet options = document.getElementById(\"options\");\n// get cDomain button (used to add current site to the blacklist)\nlet cDomain = document.getElementById(\"cDomain\");\n\nlet virustotalDiv = document.getElementById(\"virustotalDiv\");\nlet statusDiv = document.getElementById(\"statusDiv\");\n\nlet navbar = document.getElementById(\"navbar\");\nlet classToggler = document.getElementById(\"classToggler\");\n\nclassToggler.addEventListener(\"click\", () => {\n  navbar.classList.toggle(\"navbar-change\");\n\n  classToggler.classList.toggle('up');\n  classToggler.classList.toggle('up-scroll');\n  classToggler.classList.toggle('down');\n  \n  virustotalDiv.classList.toggle('virustotalDivScroll');\n});\n\n\n\n\n\n\n//  will listen for popup open and then send request to the virustotal api with the current url if possible\n\ndocument.addEventListener('DOMContentLoaded', function () {\n  // only get domain, not full url\n  let currentDomain = chrome.tabs.query({\n    currentWindow: true,\n    active: true,\n  });\n  currentDomain.then((tab) => {\n    postVirustotalAPIRequest(tab[0].url);\n    console.log(tab[0].url);\n  });\n});\n\n\n// adding listeners to DOM elements triggering their responsible functions\ncurrentToBlacklist.addEventListener(\"click\", addCurrent);\ncurrentToWhitelist.addEventListener(\"click\", function() {\n  // get current url\n  let currentDomain = chrome.tabs.query({\n    currentWindow: true,\n    active: true,\n  });\n  currentDomain.then((tab) => {\n    const domain = tab[0].url;\n    addToWhiteList(domain);\n  });\n});\noptions.addEventListener(\"click\", openOptions);\n\n/**\n *function openOptions opens extension's settings page on a new tab\n */\nfunction openOptions() {\n  chrome.runtime.openOptionsPage();\n}\n\n// if user clicks add current domain to blacklist on popup.html, this function is called\n// this function parses url to regex used while comparing current url to the blacklisted ones\nfunction addCurrent() {\n    // get current url\n    let currentDomain = chrome.tabs.query({\n      currentWindow: true,\n      active: true,\n    });\n    currentDomain.then((tab) => {\n      const domain = tab[0].url;\n\n      if (domain.startsWith(\"http\")) {\n        // use regex to parse the url, so we can use it for comparing\n        let regDom = domain\n          .replace(\"http://\", \"\")\n          .replace(\"https://\", \"\")\n          .replace(\"www.\", \"\")\n          .split(/[/?#]/)[0];\n\n          let domainList = checkForDuplicates(domain, regDom, function(domainList) {\n            console.log(domainList)\n          \n\n          if(domainList) {\n        // create object constisting of full url and the parsed one\n        let object = {\n          domain: domain,\n          regex: regDom,\n        };\n\n        // add it to the blacklisted list and save it to local storage\n        domainList.push(object);\n\n        let parsed = JSON.stringify(domainList);\n        console.log(parsed);\n        chrome.storage.local.set({\n          blackList: parsed,\n        });\n        console.log(\"succesfully added site to blacklist\");\n      } else {\n        console.log(\"List could not be retrieved\");\n        return;\n      }\n    });\n      }\n    });\n}\n\nfunction getApiKey() {\n    return new Promise(function(resolve, reject) {\n      let getKey = chrome.storage.local.get(\"apikey\");\n          getKey.then((res) => {\n      if(res.apikey) {\n        resolve(res.apikey);\n      } else {\n        reject(new Error(\"There is no ApiKey set in the storage\"));\n      }\n    });\n  });\n}\n\n/**\n       * Returns getVirusTotalAPIResults function call = we firstly need to post the url to examine\n       * the api then returns an id, where we get the final result using GET request\n       *\n       * @param {string} url - url that is going to be POSTed to the API\n       * @returns {function call} calls function which retrieves the scan result\n       */\n\n       \n      async function postVirustotalAPIRequest(url) {\n        let X_APIKey = await getApiKey(); \n        X_APIKey = X_APIKey.replaceAll('\"', \"\");\n        \n        const body = new FormData();\n        body.append(\"url\", url);\n      \n        const data = new URLSearchParams();\n        for (const pair of body) {\n          data.append(pair[0], pair[1]);\n        }\n      \n        fetch(\"https://www.virustotal.com/api/v3/urls\", {\n          body: data,\n          headers: {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"X-Apikey\":X_APIKey\n          },\n          method: \"POST\"\n        })\n          .then((response) => response.json())\n          .then((data) => {\n            console.log(url);\n            if(data){\n            getVirustotalAPIResults(data.data.id, X_APIKey, url)\n          }\n          });\n      }\n     \n      /**\n       * Returns JSON result of a previous url scan\n       *\n       * @param {string} id - this id corresponds to the scan we POSTed and want to retrieve the results of\n       * @param {string} X_APIKey - virustotal API auth API key\n       * @param {string} url - url that was POSTed to the API\n       * \n       * @returns {function call} returns json scan result of the url posted\n       */\n      \n      function getVirustotalAPIResults(id, X_APIKey, url) {   \n        console.log(url)\n        console.log(`id ${id}`);\n          fetch(`https://www.virustotal.com/api/v3/analyses/${id}`, {\n              headers: {\n                  \"X-Apikey\":`${X_APIKey}`\n                },\n              method: \"GET\"\n            })\n            .then((response) => response.json())\n            .then((data) => {\n              console.log(data);\n              showVirutstotalAPIResults(data, url, id)\n            }); \n      }\n\n      /**\n       * Parses Virustotal API results and calls addClass function depending on the result\n       *\n       * @param {string} takes an id from the previous function. That id corresponds with the final json result\n       * @param {string} url - examined url, used to display it in the popup\n       * \n       * @returns {function call} calls addClass function \n       */\n\n      function showVirutstotalAPIResults(data, url, id) {\n        let stats = data.data.attributes.stats;\n        console.log(stats);\n\n        let antiVirusCount = +stats.harmless + +stats.malicious + +stats.suspicious;\n        console.log(antiVirusCount);\n/*\n        if(antiVirusCount == 0) {\n          virustotalDiv.innerHTML = \"failed to fetch\";\n        }\n*/\n        if(stats.harmless > stats.malicious && stats.harmless > stats.suspicious) {\n          let percent = Math.round(stats.harmless/antiVirusCount*100);\n          //virustotalDiv.innerHTML = `Virustotal url scan: <br> ${stats.harmless} out of ${antiVirusCount} consider ${url} <br> harmless`;\n          virustotalDiv.innerHTML = `<h1>${percent}%</h1>`\n          statusDiv.innerHTML = \"<h5>harmless</h5>\";\n          return addClass(\"green\");\n        }\n        \n        else if(stats.suspicious > stats.harmless && stats.suspicious > stats.malicious) {\n          let percent = Math.round(stats.suspicious/antiVirusCount*100);\n          //virustotalDiv.innerHTML = `<br> ${stats.suspicious} out of ${antiVirusCount} consider ${url} suspicious`;\n          virustotalDiv.innerHTML = `<h1>${percent}%</h1>`\n          return addClass(\"Yellow\");\n        }\n\n        else if(stats.malicious > stats.harmless && stats.malicious > stats.suspicious) {\n          let percent = Math.round(stats.malicious/antiVirusCount*100);\n          //virustotalDiv.innerHTML = `<br> ${stats.malicious} out of ${antiVirusCount} consider ${url} malicious`;\n          virustotalDiv.innerHTML = `<h1>${percent}%</h1>`\n          return addClass(\"Red\");\n        }\n      }\n\n       /**\n       * \n       *  Adds predefined CSS class to fillbox element in order to trigger water like animation\n       *  to display virustotal result percentage\n       * \n       */\n\n      function addClass(color) {\n        let fillBox = document.getElementById(\"fillBox\");\n\n        switch(color) {\n          case \"green\":\n            fillBox.classList.add(\"fillBoxGreen\"); \n            break;\n          case \"orange\":\n            fillBox.classList.add(\"fillBoxOrange\"); \n            break;\n          case \"red\":\n            fillBox.classList.add(\"fillBoxRed\"); \n            break;\n        }\n      }\n \n\n\n"],"names":[],"sourceRoot":""}