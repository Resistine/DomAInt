{"version":3,"file":"./src/options.js","mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://domaint/./src/mergedSettings.js","webpack://domaint/webpack/bootstrap","webpack://domaint/webpack/runtime/define property getters","webpack://domaint/webpack/runtime/hasOwnProperty shorthand","webpack://domaint/webpack/runtime/make namespace object","webpack://domaint/./src/options.js"],"sourcesContent":["// getting DOM elements from popup.html\n\n// get toggleButton (used to enable/disable autoClose)\nlet toggleButton = document.getElementById(\"toggleButton\");\n//let clearWhitelist = document.getElementById(\"clearWhiteList\");\n\nlet blackListdiv = document.getElementById(\"blacklist\");\nlet whiteListdiv = document.getElementById(\"whitelist\");\n\n// adding listeners to DOM elements triggering their responsible functions\nif (toggleButton) {\n    toggleButton.addEventListener(\"click\", toggle);\n}\n/**\n \n *toggle function is responsible for turning off/on blacklist site autoclose\n *and saving the value to the local storage\n */\nexport function toggle() {\n    console.log(\"toggle\");\n    // get autoclose and its values from browser storage\n    let autoClose = chrome.storage.local.get(\"autoClose\");\n    autoClose.then((res) => {\n        // set the setting to the html value\n        let settings = chrome.storage.local.set({\n            autoClose: toggleButton.checked\n        });\n        //after settings are saved, update the html button's value to the set one\n        settings.then(function () {\n            updateButton();\n        });\n    });\n}\n\n/**\n * function updateButton is called when on optionsPage, when the autoClose settings are changed\n */\nexport function updateButton() {\n    //get the value from browser storage\n    let buttonVal = chrome.storage.local.get(\"autoClose\");\n    buttonVal.then((val) => {\n        // if autoClose is not enabled yet or does not exist, disable it by default\n        if (!val.autoClose || val.autoClose == null) {\n            toggleButton.checked = false;\n            //otherwise set it enable it\n        } else {\n            toggleButton.checked = true;\n        }\n    });\n}\n\n\nexport function checkForDuplicates(domain, regDom, callback) {\n    let blackListedSites;\n    let whiteListedSites;\n\n    // get blackListed sites from browser storage\n    let blackList = chrome.storage.local.get(\"blackList\");\n    blackList.then((res) => {\n        // check if there are any blacklisted sites\n        if (!res.blackList || res.blackList.length < 1) {\n            blackListedSites = [];\n            // parse blackListed sites to object\n        } else {\n            blackListedSites = JSON.parse(res.blackList);\n        }\n        // get whiteListed sites from browser storage\n        let whiteList = chrome.storage.local.get(\"whiteList\");\n        whiteList.then((res) => {\n            // check if there are any blacklisted sites\n            if (!res.whiteList || res.whiteList.left < 1) {\n                whiteListedSites = [];\n                // parse blackListed sites to object\n            } else {\n                whiteListedSites = JSON.parse(res.whiteList);\n            }\n\n            //check if site, user wishes to block is not already blocked\n            if (blackListedSites.some(e => e[\"domain\"] === domain) || blackListedSites.some(x => x[\"regex\"] === regDom)) {\n                //log if so\n                //TODO create some sort of flash message to popup and options page\n                console.log(\"this site is already being blocked\");\n                return;\n            } else {\n                for (let j = 0; j < whiteListedSites.length; j++) {\n                    if (whiteListedSites[j][\"domain\"] == domain || whiteListedSites[j][\"regex\"] == regDom) {\n                        console.log(`removed ${whiteListedSites[j][\"domain\"]} from the whitelist`);\n                        whiteListedSites.splice(j, 1);\n\n                        chrome.storage.local.set({\n                            whiteList: JSON.stringify(whiteListedSites),\n                        });\n                        break;\n                    }\n                }\n            }\n\n\n            console.log(blackListedSites);\n            callback(blackListedSites);\n        });\n    });\n\n}\n\n\nexport function checkForDuplicatesWhitelist(domain, regDom, callback) {\n    let whiteListedSites;\n    let blackListedSites;\n\n    // get whiteListed sites from browser storage\n    let whiteList = chrome.storage.local.get(\"whiteList\");\n    whiteList.then((res) => {\n        // check if there are any blacklisted sites\n        if (!res.whiteList || res.whiteList.left < 1) {\n            whiteListedSites = [];\n            // parse blackListed sites to object\n        } else {\n            whiteListedSites = JSON.parse(res.whiteList);\n        }\n\n        // get blackListed sites from browser storage\n        let blackList = chrome.storage.local.get(\"blackList\");\n        blackList.then((res) => {\n            // check if there are any blacklisted sites\n            if (!res.blackList || res.blackList.left < 1) {\n                blackListedSites = [];\n                // parse blackListed sites to object\n            } else {\n                blackListedSites = JSON.parse(res.blackList);\n            }\n\n            //check if site, user wishes to block is not already blocked\n            if (whiteListedSites.some(e => e[\"domain\"] === domain) || whiteListedSites.some(x => x[\"regex\"] === regDom)) {\n                //log if so\n                //TODO create some sort of flash message to popup and options page\n                console.log(\"this site is already in the whitelist\");\n                return;\n            } else {\n                for (let j = 0; j < blackListedSites.length; j++) {\n                    if (blackListedSites[j][\"domain\"] == domain || blackListedSites[j][\"regex\"] == regDom) {\n                        console.log(`removed ${blackListedSites[j][\"domain\"]} from the blacklist`);\n                        blackListedSites.splice(j, 1);\n\n                        chrome.storage.local.set({\n                            blackList: JSON.stringify(blackListedSites),\n                        });\n                        break;\n                    }\n                }\n            }\n\n            console.log(whiteListedSites);\n            callback(whiteListedSites);\n\n        });\n    });\n}\n\n\n\n/**\n *function addSite gets URL value from html form user wishes to whitelist\n */\nexport function addToWhiteList(url) {\n    let domain = url;\n    // parse full url to domain adress only\n    let regDom = domain\n            .replace(\"http://\", \"\")\n            .replace(\"https://\", \"\")\n            .replace(\"www.\", \"\")\n            .split(/[/?#]/)[0];\n\n    let whiteListedSites = checkForDuplicatesWhitelist(domain, regDom, function (whiteListedSites) {\n        console.log(whiteListedSites);\n\n        if (whiteListedSites) {\n            // create object made of full URL and parsed URL\n            const object = {\n                domain: domain,\n                regex: regDom,\n            };\n\n            // push the previous object to the existing whitelist\n            whiteListedSites.push(object);\n\n            // save whiteListed sites to the browser storage\n            chrome.storage.local.set({\n                whiteList: JSON.stringify(whiteListedSites),\n            });\n\n            //log if succesfully accomplished\n            //TODO create some sort of flash message to popup and options page\n            console.log(\"succesfully added domain to the whiteList\");\n        } else {\n            return;\n        }\n    });\n}\n\nexport function getBlacklist() {\n    let blackListedSites;\n\n    // get blackListed sites from browser storage\n    let blackList = chrome.storage.local.get(\"blackList\");\n    blackList.then((res) => {\n        // check if there are any blacklisted sites\n        if (!res.blackList || res.blackList.length < 1) {\n            blackListedSites = [];\n            // parse blackListed sites to object\n        } else {\n            blackListedSites = JSON.parse(res.blackList);\n        }\n\n        return new Promise(function (resolve, reject) {\n            if (blackListedSites) {\n                resolve(blackListedSites);\n            } else {\n                reject(new Error(\"could not return the blacklist\"));\n            }\n        });\n    });\n}\n\nexport function getWhitelist() {\n    let whiteListedSites;\n\n    // get whiteListed sites from browser storage\n    let whiteList = chrome.storage.local.get(\"whiteList\");\n    whiteList.then((res) => {\n        // check if there are any whitelisted sites\n        if (!res.whiteList || res.whiteList.length < 1) {\n            whiteListedSites = [];\n            // parse whiteListed sites to object\n        } else {\n            whiteListedSites = JSON.parse(res.whiteList);\n        }\n\n        return new Promise(function (resolve, reject) {\n            if (whiteListedSites) {\n                resolve(whiteListedSites);\n            } else {\n                reject(new Error(\"could not return the whitelist\"));\n            }\n        });\n    });\n}\n\nif (toggleButton) {\n    updateButton();\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import {checkForDuplicates} from \"./mergedSettings\"\n\nlet blackListdiv = document.getElementById(\"blacklist\");\nlet whiteListdiv = document.getElementById(\"whitelist\");\n\n// get html form used to add sites to blacklist\nlet blacklistForm = document.getElementById(\"form\");\n// get html form used to add sites to whitelist\nlet whitelistForm = document.getElementById(\"whitelistForm\");\n// get html form used to configure custom AI threshold\nlet thresholdForm = document.getElementById(\"thresholdForm\");\n// get html form used to setup virustotal API calls\nlet apiForm = document.getElementById(\"apiForm\");\n// get clear button (used to clear the whole blackList)\nlet clear = document.getElementById(\"clear\");\n// get clear button (used to clear the whole whiteList)\nlet clearWhitelist = document.getElementById(\"clearWhite\");\n\n/**\n * Color elements, threshold ranges and values\n * @type Element\n */\nconst green = document.getElementById(\"greenRange\");\n// grey is implicit\nconst orange = document.getElementById(\"orangeRange\");\nconst red = document.getElementById(\"redRange\");\n\n// get html range values\nlet greenVal = document.getElementById(\"greenVal\");\n// grey is implicit\nlet orangeVal = document.getElementById(\"orangeVal\");\nlet redVal = document.getElementById(\"redVal\");\n\n// div used to describe what will the threshold work like\nlet meaning = document.getElementById(\"meaning\");\n\n// add event listener on new submited url to be blacklisted\nblacklistForm.addEventListener(\"submit\", addSite);\n// add event listener on new submited url to be whitelisted\nwhitelistForm.addEventListener(\"submit\", function() {\n  let domain = document.querySelector('input[name=\"whitelistUrl\"]').value;\n  addToWhiteList(domain);\n});\n\napiForm.addEventListener(\"submit\", addAPIKey);\n\nthresholdForm.addEventListener(\"submit\", configureThreshold);\n\nclear.addEventListener(\"click\", clearBLackList);\nclearWhitelist.addEventListener(\"click\", clearWhiteList);\n\n\n/**\n * function showBlacklistedSites retrieves all blacklisted sites from local storage\n * and if there are any, display them to the html\n * function also add event listener to each of the sites, so user might remove each one by one\n */\nfunction showBlacklistedSites() {\n    // TODO: check if the user wants to get this info?\n    \n    // get blacklisted sites from browser storage\n    let blackList = chrome.storage.local.get(\"blackList\");\n    blackList.then((res) => {\n        // if theres no site being blacklisted\n        if (!res.blackList || res.blackList.length < 1) {\n            // if there are blacklisted sites\n        } else {\n            // parse blacklisted sites to object\n            let blackListArray = JSON.parse(res.blackList);\n            // log the blacklisted sites\n            // foreach blacklisted site\n            let i = 0;\n            blackListArray.forEach((site) => {\n                // show what sites are being blocked in the html div\n                blackListdiv.innerHTML += `<div class = \"list-group-item\">\n<img class = \"favicon\" src = \"https://www.google.com/s2/favicons?domain=${site.regex}\">\n<span class=\"domain\">\n${site.regex} \n</span>\n<span class=\"removeFromListBlacklist\" id=\"${i}\">\n<svg width=\"1.5em\" height=\"1.5em\" viewBox=\"0 0 16 16\" class=\"bi bi-x\" fill=\"currentColor\" xmlns=\"http://www.w3.org/2000/svg\">\n<path fill-rule=\"evenodd\" d=\"M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z\"/>\n</svg>\n</span>\n</div>`;\n                i++;\n            });\n\n            // TODO: Comment this pls\n            let removeFromList = document.getElementsByClassName(\"removeFromListBlacklist\");\n            console.log(removeFromList.length);\n            for (let i = 0; i<removeFromList.length; i++) {\n                console.log(removeFromList[i]);\n                removeFromList[i].addEventListener(\"click\", function() {\n                    console.log(removeFromList[i]);\n                    removeSiteFromLists(\"blacklist\", removeFromList[i].id);\n                })\n            }\n        }\n    });\n}\n\n\n\n/**\n  * removes single site from blacklist or whitelist\n  *\n  * @param {string} type - either blacklist or whitelist\n  * @returns {string} id - html id of the site\n  */\nfunction removeSiteFromLists(type, id) {\n    if (type == \"whitelist\") {\n        let whiteListedSites;\n        // get blackListed sites from browser storage\n        let whiteList = chrome.storage.local.get(\"whiteList\");\n        whiteList.then((res) => {\n        // check if there are any blacklisted sites\n        if (!res.whiteList || res.whiteList.left < 1) {\n        whiteListedSites = [];\n                // parse blackListed sites to object\n        } else {\n        whiteListedSites = JSON.parse(res.whiteList);\n        }\n        whiteListedSites.splice(id, 1);\n                chrome.storage.local.set({\n                whiteList: JSON.stringify(whiteListedSites),\n                });\n        });\n    }\n    else if (type == \"blacklist\") {\n        let blackListedSites;\n        // get blackListed sites from browser storage\n        let blackList = chrome.storage.local.get(\"blackList\");\n        blackList.then((res) => {\n        // check if there are any blacklisted sites\n        if (!res.blackList || res.blackList.left < 1) {\n        blackListedSites = [];\n                // parse blackListed sites to object\n        } else {\n        blackListedSites = JSON.parse(res.blackList);\n        }\n        blackListedSites.splice(id, 1);\n                chrome.storage.local.set({\n                blackList: JSON.stringify(blackListedSites),\n                });\n        });\n    }\n    location.reload();\n}\n\n\n/**\n *function clearBlacklist removes all sites from the blacklist\n */\n\nfunction clearBLackList() {\n    let empty = [];\n    chrome.storage.local.set({\n        blackList: JSON.stringify(empty),\n    });\n    console.log(\"successfully cleared BlackList\");\n    if (blackListdiv) {\n        blackListdiv.innerText = \"\";\n    }\n}\n\n/**\n * function clearWhiteList removes all sites from the whitelist\n */\nfunction clearWhiteList() {\n    let empty = [];\n    chrome.storage.local.set({\n        whiteList: JSON.stringify(empty),\n    });\n    console.log(\"successfully cleared whiteList\");\n    if (whiteListdiv) {\n        whiteListdiv.innerText = \"\";\n    }\n}\n\n\n\n/**\n * renders each whitelisted site from local storage in the option html\n * also adds event listeners, so that pages can be removed one by one\n */\nfunction showWhitelistedSites() {\n    // get blacklisted sites from browser storage\n    let whiteList = chrome.storage.local.get(\"whiteList\");\n    whiteList.then((res) => {\n        // if theres no site being blacklisted\n        if (!res.whiteList || res.whiteList.length < 1) {\n\n            // if there are blacklisted sites\n        } else {\n            // parse blacklisted sites to object\n            let whiteListArray = JSON.parse(res.whiteList);\n            // log the blacklisted sites\n            // foreach blacklisted site\n            let i = 0;\n            whiteListArray.forEach((site) => {\n                // show what sites are being blocked in the html div\n                whiteListdiv.innerHTML += `<div class = \"list-group-item\">\n<img class = \"favicon\" src = \"https://www.google.com/s2/favicons?domain=${site.regex}\"> <span class=\"domain\">\n${site.regex} \n</span>\n<span class=\"removeFromList\" id=\"${i}\">\n<svg width=\"1.5em\" height=\"1.5em\" viewBox=\"0 0 16 16\" class=\"bi bi-x\" fill=\"currentColor\" xmlns=\"http://www.w3.org/2000/svg\">\n<path fill-rule=\"evenodd\" d=\"M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z\"/>\n</svg>\n</span>\n</div>`;\n                i++;\n            });\n            let removeFromList = document.getElementsByClassName(\"removeFromList\");\n            console.log(removeFromList.length);\n            for (let i = 0; i < removeFromList.length; i++) {\n                console.log(removeFromList[i]);\n                removeFromList[i].addEventListener(\"click\", function () {\n                    console.log(removeFromList[i]);\n                    removeSiteFromLists(\"whitelist\", removeFromList[i].id);\n                })\n            }\n        }\n    });\n}\n\n\n/**\n *function addSite gets URL value from html form user wishes to blacklist\n */\nfunction addSite() {\n    // get  value from form input\n    let domain = document.querySelector('input[name=\"url\"]').value;\n    // declare variable for blackListed sites -> global scope variable\n\n    // parse full url to domain adress only\n    let regDom = domain\n            .replace(\"http://\", \"\")\n            .replace(\"https://\", \"\")\n            .replace(\"www.\", \"\")\n            .split(/[/?#]/)[0];\n\n    let blackListedSites = checkForDuplicates(domain, regDom, function (blackListedSites) {\n        console.log(blackListedSites);\n\n        if (blackListedSites) {\n            // create object made of full URL and parsed URL\n            const object = {\n                domain: domain,\n                regex: regDom,\n            };\n\n            // push the previous object to the existing blacklist\n            blackListedSites.push(object);\n\n            // save blackListed sites to the browser storage\n            chrome.storage.local.set({\n                blackList: JSON.stringify(blackListedSites),\n            });\n\n            //log if succesfully accomplished\n            //TODO create some sort of flash message to popup and options page\n            console.log(\"succesfully added domain to the blacklist\");\n        } else {\n            return;\n        }\n    });\n}\n\n\n\n/**\n * function configureThreshold saves the threshold from settings from to he local storage\n */\nfunction configureThreshold() {\n    const object = {green: green.value, orange: orange.value, red: red.value};\n\n    // save threshold to the browser storage\n    chrome.storage.local.set({\n        threshold: JSON.stringify(object)\n    });\n}\n\n/**\n * on site load, this function shows Threshold settings from local storage or the default ones\n */\nfunction showThreshold() {\n    // get blacklisted sites from browser storage\n    let threshold = chrome.storage.local.get(\"threshold\");\n    threshold.then((res) => {\n        // if theres no site being blacklisted\n        if (!res.threshold || res.threshold.length < 1) {\n            green.value = 20;\n            greenVal.innerText = 20 + \"%\";\n\n            orange.value = 60;\n            orangeVal.innerText = 60 + \"%\";\n\n            red.value = 90;\n            redVal.innerText = 90 + \"%\";\n        } else {\n            // parse blacklisted sites to object\n            let threshold = JSON.parse(res.threshold);\n            // log the blacklisted sites\n            console.log(threshold);\n\n            green.value = threshold.green;\n            greenVal.innerText = green.value + \"%\";\n\n            orange.value = threshold.orange;\n            orangeVal.innerText = orange.value + \"%\";\n\n            red.value = threshold.red;\n            redVal.innerText = red.value + \"%\";\n\n        }\n        editMeaning();\n    });\n}\n\n/**\n * desribes what will model work like with current Threshold configuration\n */\n\nfunction editMeaning() {\n    meaning.innerHTML = \"<p>\";\n    meaning.innerText += `According to these settings, the model will work as follows: \nTill ${green.value}% the site will be rated as safe.\nBetween the green and the orange value, there is the grey area, we don't know much about.'\nFrom ${orange.value}% to ${red.value}% the site will be rated as potencionaly dangerous.\nFrom ${red.value}% on, the site will be rated as dangerous.\n`;\n}\n\n/**\n * takes apikey value from form and saves it to the local storage // might not be the best solution\n */\nfunction addAPIKey() {\n    let APIKey = document.querySelector('input[name=\"apikey\"]').value;\n    console.log(APIKey);\n    chrome.storage.local.set({\n        apikey: JSON.stringify(APIKey)\n    });\n}\n\n\n/*\n * oninput section for all 3 threshold sliders, moves other sliders if necessary, changes text value\n */\ngreen.oninput = function () {\n    greenVal.innerText = green.value + \"%\";\n    if (+green.value > +orange.value) {\n        orange.value = +green.value + 1;\n        orangeVal.innerText = orange.value + \"%\";\n    }\n    if (+orange.value > +red.value && +red.value <= 99) {\n        red.value = +orange.value + 1;\n        redVal.innerText = red.value + \"%\";\n    }\n    editMeaning();\n};\n\norange.oninput = function () {\n    orangeVal.innerText = orange.value + \"%\";\n\n    if (+orange.value > +red.value) {\n        red.value = +orange.value + 1;\n        redVal.innerText = red.value + \"%\";\n    }\n\n    if (+orange.value < +green.value) {\n        green.value = orange.value - 1;\n        greenVal.innerText = green.value + \"%\";\n    }\n    editMeaning();\n};\n\nred.oninput = function () {\n    redVal.innerText = red.value + \"%\";\n    if (+red.value < +orange.value && +orange.value > 1) {\n        orange.value = +red.value - 1;\n        orangeVal.innerText = orange.value + \"%\";\n    }\n    if (+orange.value < +green.value && +green.value > 1) {\n        green.value = +orange.value - 1;\n        greenVal.innerText = green.value + \"%\";\n    }\n    editMeaning();\n};\n\n\n  \n\n\n\n// TODO: Comment the output\nshowBlacklistedSites();\nshowWhitelistedSites();\nshowThreshold();\n\n"],"names":[],"sourceRoot":""}